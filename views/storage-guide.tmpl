{% import "views/_helper.njk" as docs %}
{% import "views/_data.njk" as data %}
{% import "views/_sms.njk" as sms %}
{% import "views/_parts.html" as include %}
{% set middot = '·' %}
{% set link_to_blog_password_reset = '关于自定义邮件模板和验证链接，请参考《[自定义应用内用户重设密码和邮箱验证页面](https://blog.leancloud.cn/607/)》。' %}
{% set app_permission_link = "[Dashboard > Data > Settings > User Account](/dashboard/storage.html?appid={{appid}}#/storage/conf)" %}
{% set query_result_limit = "A query returns 100 records by default. You can change the number of  results by setting limit. See [Limiting Query Results](#limiting-query-results) for more info." %}

# Cloud Storage Guide

Storing data on LeanCloud and getting it back is what our JavaScript SDK is good at. If you come from a background of writing SQL for tradtional databases, however, you'll find it very different from the way you are used to.

For example, a typical SQL statement that adds a new record looks like this (assuming database schema had already been created):

```sql
INSERT INTO Todo (title, content) VALUES ('R&D Weekly Meeting', 'All team members, Tues 2pm')
```

Using our JavaScript SDK, you write:

```js
  // tell the cloud which class 
  // (or table, in a common sense) to use
  var Todo = AV.Object.extend('Todo');

  var todo = new Todo();

  todo.set('title', 'R&D Weekly Meeting');
  todo.set('content', 'All team members, Tue 2pm');

  todo.save().then(function (todo) {
    // saved successully
    console.log('object id is:' + todo.id);
  }, function (error) {
    // operation failed
    console.error('error message: ' + error.message);
  });
```

This piece of code reads and writes to the cloud, and takes care of schema creation and error handling at the same time. Pretty  cool, eh?

So let's delve into the water and have some fun.

## Getting Started

Our JavaScript SDK supports Chrome 31+, Firefox latest, IE 9+ and Edge, iOS 8.0+ and Android 4.4+ via WebView, WeApp DevTools latest, as well as Node.js 0.12+ and React Native 0.26+.

### Using JavaScript SDK on Different Platforms

The easiest way to integrate our JavaScript SDK into your web project is through the npm module.

```bash
# push notification & analytics are included in the leancloud-storage
$ npm install leancloud-storage --save
```

To use the npm modules for a browser based application or in a Node.js environment, include it as you normally would:

```js
var AV = require('leancloud-storage');

// create reference to the global AV
var { Query, User } = AV;

// initialization code
AV.init('APP_ID', 'APP_KEY');
```

However, if you want to use a pre-compiled file, you can fetch it from here:

```html
<script src="//cdn1.lncld.net/static/js/{{jssdkversion}}/av-min.js"></script>
```
And get a reference to the SDK: 

```js
var { Query, User } = AV;

// initialization code
AV.init('APP_ID', 'APP_KEY');
```

Check out our Github repo https://github.com/leancloud/javascript-sdk/releases for more releases and formats.

If you are planning to use our JavaScript SDK inside Adroid WebView, please check out [WebView](#WebView) section.

If you rely on features of [LiveQuery](livequery.html), modify the way you import the SDK as shown below: 

```js
// no need to require 'leancloud-storage' package again
var AV = require('leancloud-storage/live-query');
```
Or loading it using `<script>` tag: 

```html
<!-- no need to load av-min.js again -->
<script src="//cdn1.lncld.net/static/js/{{jssdkversion}}/av-live-query-min.js"></script>
```

### Initializing Your Application

Go to your app's [LeanCloud dashboard setting page](/dashboard/app.html?appid={{appid}}#/key), and look for your your App ID and App Key, copy and paste them into your initialization code.

```js
var APP_ID  = '{{appId}}';
var APP_KEY = '{{appKey}}';

// same as AV.init('APP_ID', 'APP_KEY')
AV.init({
  appId:  APP_ID,
  appKey: APP_KEY,
  // specify region=us if your app was created in the US site, 
  region: 'us'
  // otherwise leave it out, region would default to China site.
});
```
The LeanCloud apps are region-specific. They neither talk nor share anything across regions. Therefore incorrect region setting will cause the initialization code to fail.

Besides, each region serves their own REST APIs. Please consult documentation for the correct URL scheme of APIs to use. US docs is available at https://us.leancloud.cn/docs/rest_api.html, and China docs is at https://leancloud.cn/docs/rest_api.html. 

### Debugging

Our SDK supports debug logging. You can turn it on during the development cycle of your application. Once enabled, details of every request made by our SDK along with errors will be output to the browser's console, or to the terminal window in a Node.js environment.

For browser based applications, open the brower's console and run the following command:

```js
localStorage.setItem('debug', 'leancloud*,LC*');
```
In Node.js, you need to set environment variable `DEBUG` to `leancloud*,LC*`.


### Web Security

If you are using our JavaScript SDK in your browser based application, you MUST configure **whitelist domains** in your app's [LeanCloud dashboard settings page](/dashboard/app.html?appid={{appid}}#/security) before you deploy it to a production environment.

Once it's been set up, our backend will only accept requests sending from the domains in that whitelist, which can prevent unauthorized usage or access to your cloud data on some level.

Yet it's not good enough to keep your data well away from web attackers and threats. It is the Internet. So we also provide a number of ways to help you safeguard your apps and data further. The security oriented articles listed below can give you necessary information you need to know.

- [Data and Security](data-security.html)

## Objects

### AV.Object

Storing data on LeanCloud is built around `AV.Object`. Each `AV.Object` contains key-value pairs of JSON-compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each `AV.Object`. You simply set whatever key-value pairs you want, and our backend will store it.

For example, let's say you're adding a todo item. A single `AV.Object` could contain:

```json
title: 'Email Linda to confirm appointment',
importance: 'high',
tags: ['project-x'], 
done: false
```

{# Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays, objects, and anything that can be JSON-encoded. #}

### Data Types

AV.Object accepts values of type String, Number, Boolean, Object, Array, Date, JSON and null. You can nest JSON Objects and JSON Arrays to store more structured data within a single AV.Object.

```js
  var TestObject = AV.Object.extend('DataTypeTest');

  var number = 2018;
  var string = 'famous film name is ' + number;
  var date = new Date();
  var array = [string, number];
  var object = { 
    number: number, 
    string: string 
  };

  var testObject = new TestObject();
  testObject.set('testNumber', number);
  testObject.set('testString', string);
  testObject.set('testDate', date);
  testObject.set('testArray', array);
  testObject.set('testObject', object);
  testObject.set('testNull', null);
  testObject.save().then(function(testObject) {
    // success
  }, function(error) {
    // failure
  });
```

We do not recommend storing large pieces of binary data like images or documents on `AV.Object`. AV.Objects should not exceed **128 kilobytes** in size. We recommend you use AVFiles to store images, documents, and other types of files. You can do so by instantiating an `AV.File` object and setting it on a field. See [Files](#files) for details.

{% call docs.noteWrap() %}
Please note that our backend will store dates in UTC format and the SDK will convert them back to local time upon retrieval.

The date values displayed in the Classes grid in your LeanCloud dashboard data page are also converted to match your operating system's timezone. The only exception is when you retrieve these dates through our REST APIs, they will remain in UTC format. You can maually convert them using appropriate timezone when necessary.   
{% endcall %}

{# For more information about how LeanCloud handles data and security, check out our documentation on [Data and Security](data-security.html). #}

### Creating Object

To create a new instance of `AV.Object`, you can do this:

```js
  var Todo = AV.Object.extend('Todo');
```
`AV.Object.extend()` requires a ClassName to be passed in so that the cloud will know which class you are targeting. You can think of a Class in the cloud as a table in a database.

A ClassName must start with a letter, and must contain only numbers, letters, and underscore.

{% call docs.noteWrap() -%}If you keep seeing "**Maximum call stack size exceeded**" exception in your log, chances are `AV.Object.extend()` had been called with the same ClassName more than once  inside a loop or a callback. Either move it out of the loop or callback to make sure it won't be over-instantiated, or use JavaScript SDK 1.4 or higher to eliminate the worries.
{%- endcall %}


From version 1.4.0 onwards, the JavaScript SDK is compatible with ES6 classes. If you're using ES6 in your codebase, you can subclass `AV.Object` with the **extends** keyword. However, when using extends, the SDK is not automatically aware of your subclass, you will need to register the subclass with the SDK:

```js
class Todo extends AV.Object {
  // more properties and methods
}
// register the subclass
AV.Object.register(Todo);
```

Then you can add additional methods and properties to your subclasses of `AV.Object`.
{# You can also use the `AV.Object` constructor directly. `new AV.Object(ClassName)` will create a single LeanCloud Object with that class name. #}

### Saving Objects

Now let's save a new Class named **"TodoFolder"** to  the cloud. TodoFolder is used to categorize different Todos, it can have many Todos.

```js
  var TodoFolder = AV.Object.extend('TodoFolder');
  var todoFolder = new TodoFolder();

  // set fields' values
  todoFolder.set('name','Work');
  todoFolder.set('priority',1);
  
  todoFolder.save().then(function (todo) {
    // Execute any logic that should take place after the object is saved.
    console.log('objectId is ' + todo.id);
  }, function (error) {
    // Execute any logic that should take place if the save fails.
  });
```

After this code runs, you will probably be wondering if anything really happened. To make sure the data was saved, you can look at [Dashboard > Data > TodoFolder](/data.html?appid={{appid}}#/) in your app on LeanCloud. You should see something like this:

```json
  "name":      "Work", 
  "priority":  1, 
  "ACL": {
    "*": {
      "read":  true,
      "write": true
    }
  },
  "objectId":  "582570f38ac247004f39c24b", 
  "createdAt": "2017-11-11T07:19:15.549Z",
  "updatedAt": "2017-11-11T07:19:15.549Z"
```
There are two things to note here. You didn't have to configure or set up a new Class called "TodoFoler" before running this code. Your LeanCloud app lazily creates this Class for you when it first encounters it.

There are also a few fields you don't need to specify that are provided as a convenience:

Built-in Fields|Type|Description
---|---|---
`objectId`| String |a unique identifier for each saved object.
`ACL`| ACL |Access Control List, which holds a JSON-compatible data defining who can access this object with read or write permissions.
`createdAt`| Date |the time that an object was created in the cloud, which remains unchanged throughout the life of the object.
`updatedAt` | Date |the time that an object was last modified in the cloud

Each of these fields is filled in by LeanCloud, so they don't exist on an `AV.Object` until a save operation has completed.

Field names, or **keys**, must be alphanumeric strings. A user-defined key can neither start with double underscores `__`, nor be identical to any system reserved words or built-in field names regardless of letter cases.

Here are the words you should avoid using to name your keys: **{{ data.preservedWords(", ") }}**.

**Values** can be strings, numbers, booleans, or even arrays and dictionaries - anything that can be JSON-encoded. See [Data Types](#data-types) for more information.

We recommend that you adopt CamelCase naming convention to NameYourClassesLikeThis and nameYourKeysLikeThis, just to keep your code looking pretty.

We have also created a SQL-flavored syntax called Cloud Query Language (CQL) for saving and querying data in the cloud. So  the code above can be rewritten using CQL like so: 

```js
  // create a TodoFolder object
  AV.Query.doCloudQuery('insert into TodoFolder (name, priority) values ("Work", 1)').then(function (data) {
    // success, results are kept in data.results
    var results = data.results;
  }, function (error) {
    // operation failed
    console.error(error);
  });
```

You can read [Cloud Query Language Guide](cql-guide.html) in detail if you are in favor of this approach to data manipulation.

### Retrieving Objects

If the `AV.Object` has been successfully saved to the cloud, you can use the `objectId` to get it using an `AV.Query`:

```js
  var query = new AV.Query('Todo');

  query.get('57328ca079bc44005c2472d0').then(function (todo) {
    //  todo is successfully retrived
    var priority = todo.get('priority');
    var location = todo.get('location');
    var title    = todo.get('title');
    var content  = todo.get('content');

    var objectId  = todo.id;
    var updatedAt = todo.updatedAt;
    var createdAt = todo.createdAt;

  }, function (error) {
    // operation failed, logic to handle exception goes here
  });
```

To get the values out of the `AV.Object`, as you can observe from the code above, use the `get` method.

Be aware that **objectId, updatedAt and createdAt**, these three special reserved values are provided as properties and cannot be retrieved using the `get` method nor modified with the `set` method. Each of these fields is filled in by the cloud only, so they don't exist on an `AV.Object` until a save operation has completed.

If you are trying to access any fields or properties that don't exist, the SDK won't error out but return **null** instead.

Sometimes you may want to get all the fields back (as in a data binding scenario) but just aren't interested in using `get` explicitly on every field. If your SDK is 3.0.0+, you can leverage an instance method `toJSON` of `AV.Object` to get a plain object containing all the fields.

```js
  var query = new AV.Query('Todo');
  query.get('558e20cbe4b060308e3eb36c').then(function (todo) {
    console.log(todo.toJSON())
    // ==== results in console ====

    // content:   "每周工程师会议，周一下午2点"
    // createdAt: "2017-03-08T11:25:07.804Z"
    // location:  "会议室"
    // objectId:  "558e20cbe4b060308e3eb36c"
    // priority:  1
    // title:     "工程师周会"
    // updatedAt: "2017-03-08T11:25:07.804Z"
    // ...

  }).catch(error) {
    // 异常处理
    console.error(error);
  });
```
#### Refreshing Objects

If you need to refresh an object you already have with the latest data that is in the cloud, you can call the `fetch` method like so:

```js
  var todo = AV.Object.createWithoutData(
    // ClassName
    'Todo',
    // objectId
    '5745557f71cfe40068c6abe0'
  );

  todo.fetch().then(function (todo) {
    // // The object was refreshed successfully
  }, function (error) {
    // an error occurred
  });
```

Remember, *any unsaved changes made to the object prior to using `fetch` will not survive*. If this is not what you want, you have the option to provide a list of **keys** to the `fetch` method so that only named fields are retrieved and refreshed (and also special built-in fields such as objectId, createdAt, and updatedAt), while changes made on other fields will remain intact.

```js
  todo.fetch({
    keys: 'priority,location'
  }).then(function (todo) {
    // only priority and location will be retrieved and refreshed
  }, function (error) {

  });
```

{# After the object is refreshed successfully, its `updatedAt` value will be updated on the client. The cloud won't have this new value until the next save or fetch happens, thus some network bandwidth can be saved out of it. #}

{# With that in mind, let's make it more fun.  Let's build a new `AV.Object` locally from scratch with an objectId, and retrieve more field values associated with this object from the cloud without using `AV.Query`.  #}

### Updating Objects

Updating an object is simple. Just set some new data on it and call the `save` method. For example:

```js
  // suppose objectId is known, then create an object out of it
  var todo = AV.Object.createWithoutData(
    // ClassName
    'Todo',
    // objectId
    '5745557f71cfe40068c6abe0');

  todo.set('content', 'Weekly meeting has been rescheduled to Wed 3pm for this week.');
  todo.save();
```

LeanCloud automatically figures out which data has changed so only "dirty" fields will be sent to the cloud. You don't need to worry about squashing data that you didn't intend to update.

If you prefer using [CQL](cql-guide.html) to update data, here's how it's done:

```js
  AV.Query.doCloudQuery('update Todo set content="Weekly meeting has been rescheduled to Wed 3pm for this week." where objectId="5745557f71cfe40068c6abe0"')
  .then(function (data) {
    var results = data.results;
  }, function (error) {
    console.error(error);
  });
```

#### Conditionally Updating Data

By using `query` option of the `save` method, you can put conditions on the save operation so that the object can be updated only when those conditions are met. Otherwise, the cloud will return error code **305** to indicate that there was no update taking place.

<a id="saveoption-query-example"></a>For example, in the Class 'Account' there is a field called **balance**, and there are multiple incoming requests that will modify the balance. An account cannot have negative balance, so we can only allow a request to update the balance when the amount requested is lower than or equal to the balance.

```js
  var Account = AV.Object.extend('Account');
  // get the first record from Account,
  // just for demonstration convenience
  new AV.Query(Account).first().then(function(account) {
    var amount = -100;
    // atomically decrease balance by 100
    account.increment('balance', amount);
    return account.save(null, {
      // use 'query' to set up the condition 
      query: new AV.Query(Account).greaterThanOrEqualTo('balance', -amount),
      fetchWhenSave: true,
    });
  }).then(function(account) {
    // the object was updated successfully
    // return current balance
    console.log('Balance: ', account.get('balance'));
  }).catch(function(error) {
    if (error.code === 305) {
    console.log('Insufficient balance! Update failed.');
    }
  });
```

*`query` option only works on existing objects.* In other words, it has no effect on objects that haven't been saved in the cloud yet.

Of course you may be wondering about the benefit of using `query` option whereas you can use `AV.Query` and `AV.Object` respectively to achieve the same goal. Sure, that would work to some extent but it's cumbersome and can lead to problems if you have multiple clients trying to update the same value. 

The above example contains another option you can use with the `save` method: `fetchWhenSave`. When set to true, the save operation will automatically return the latest data that is in the cloud upon completion. All the fields will be returned if the object is new, or only "dirty" fields if it's not. See [Counters](#counters) for more use cases.

#### Counters

The above example contains a common use case. The "balance" field is a counter that we'll need to continually update with the transaction amount. Using the above method works but it's cumbersome and can lead to problems if you have multiple clients trying to update the same counter.

To help with storing counter-type data, LeanCloud provides methods that atomically increment (or decrement) any number field.

```js
var todo = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');
  todo.set('views', 0);
  todo.save().then(function (todo) {
    todo.increment('views');
    todo.fetchWhenSave(true);
    return todo.save();
  }).then(function (todo) {
    // fetchWhenSave is enabled, so the latest value of 'views' will be returned 
  }, function (error) {

  });
```

You can also increment by any amount by passing in a second argument to `increment`. When no amount is specified, 1 is used by default.

#### Arrays

To help with storing array data, there are three operations that can be used to atomically change an array associated with a given key:

- `AV.Object.add('arrayKey', value)` <br/>append the given object to the end of an array field.
- `AV.Object.addUnique('arrayKey', value)` <br/>add the given object only if it isn't already contained in an array field. The position of the insert is not guaranteed.
- `AV.Object.remove('arrayKey', value)`<br/> remove all instances of the given object from an array field.

For example, Todo has a field called **alarms** for keeping track of times at which a user wants to be alerted about the todo item. You can add items to the alarms field like so:

```js
  var alarm1 = new Date('2015-11-11 07:10:00');
  var alarm2 = new Date('2015-11-11 07:20:00');
  var alarm3 = new Date('2015-11-11 07:30:00');
  var alarms = [alarm1, alarm2, alarm3];

  var todo = new AV.Object('Todo');

  todo.addUnique('alarms', alarms);

  todo.save().then(function (todo) {
    console.log(todo.id);
  }, function (error) {
    console.error(error);
  });
```

{# Note that it is not currently possible to atomically add and remove items from an array in the same save. You will have to call `save` in between every different kind of array operation. #}

### Destroying Objects

To delete a "finished" Todo object from the cloud:

```js
  var todo = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');
  todo.destroy().then(function (success) {
    // the object is successfully deleted
  }, function (error) {
    // error
  });
```
Or use [CQL](cql-guide.html): 

```js
  AV.Query.doCloudQuery('delete from Todo where objectId="558e20cbe4b060308e3eb36c"').then(function () {
    // the object is successfully deleted
  }, function (error) {
    // error
  });
```

{# For security reasons, LeanCloud Removing data from the cloud is taken as a performed with caution.

<div class="callout callout-danger">删除对象是一个较为敏感的操作。在Dashboard创建对象的时候，默认开启了权限保护，关于这部分的内容请阅读《[ACL 权限管理指南](acl-guide.html)》。</div> 

You can delete a single field from an object with the unset method:

{% block section_delete_options %}
{% block code_delete_options %}{% endblock %}
{% endblock %}
Please note that use of object.set(null) to remove a field from an object is not recommended and will result in unexpected functionality.
#}

{% block text_batch_operation %}
### Batch Operations

为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行创建、更新、删除、获取。接口都在 `{{baseObjectName}}` 这个类下面：

{% block code_batch_operation %}{% endblock %}

批量设置 Todo 已经完成：

{% block code_batch_set_todo_completed %}{% endblock %}

不同类型的批量操作所引发不同数量的 API 调用，具体请参考 [API 调用次数的计算](faq.html#API_调用次数的计算)。
{% endblock %}
{% block text_work_in_background %}
### 后台运行
细心的开发者已经发现，在所有的示例代码中几乎都是用了异步来访问 Cloud storage 云端，形如 `{{backgroundFunctionTemplate}}` 的方法都是提供给开发者在主线程调用用以实现后台运行的方法，因此开发者在主线程可以放心的调用这种命名方式的函数。另外，需要强调的是：**回调函数的代码是在主线程执行。**
{% endblock %}

{% block save_eventually %}
### 离线storage对象

大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 {{saveEventuallyName}} 来代替。

它的优点在于：如果用户目前尚未接入网络，{{saveEventuallyName}} 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，Cloud storage 会再次尝试保存操作。

所有 {{saveEventuallyName}}（或 {{deleteEventuallyName}}）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 {{saveEventuallyName}} 是安全的。

{% endblock %}

### Relational Data

Objects may have relationships with other objects. For example, in a blogging application, a Post object may have many Comment objects. LeanCloud supports all kind of relationships, including one-to-one, one-to-many, and many-to-many.

ONE-TO-ONE AND ONE-TO-MANY RELATIONSHIPS
One-to-one and one-to-many relationships are modeled by saving an AV.Object as a value in the other object. For example, each Comment in a blogging app might correspond to one Post.

To create a new Post with a single Comment, you could write:


// Declare the types.
var Post = AV.Object.extend("Post");
var Comment = AV.Object.extend("Comment");

// Create the post
var myPost = new Post();
myPost.set("title", "I'm Hungry");
myPost.set("content", "Where should we go for lunch?");

// Create the comment
var myComment = new Comment();
myComment.set("content", "Let's do Sushirrito.");

// Add the post as a value in the comment
myComment.set("parent", myPost);

// This will save both myPost and myComment
myComment.save();
Internally, the LeanCloud framework will store the referred-to object in just one place, to maintain consistency. You can also link objects using just their objectIds like so:


var post = new Post();
post.id = "1zEcyElZ80";

myComment.set("parent", post);
By default, when fetching an object, related AV.Objects are not fetched. These objects' values cannot be retrieved until they have been fetched like so:


var post = fetchedComment.get("parent");
post.fetch({
  success: function(post) {
    var title = post.get("title");
  }
});
MANY-TO-MANY RELATIONSHIPS
Many-to-many relationships are modeled using AVRelation. This works similar to storing an array of AV.Objects in a key, except that you don't need to fetch all of the objects in a relation at once. In addition, this allows AVRelation to scale to many more objects than the array of AV.Object approach. For example, a User may have many Posts that she might like. In this case, you can store the set of Posts that a User likes using relation. In order to add a Post to the “likes” list of the User, you can do:


var user = AVUser.current();
var relation = user.relation("likes");
relation.add(post);
user.save();
You can remove a post from an AVRelation:


relation.remove(post);
user.save();
You can call add and remove multiple times before calling save:


relation.remove(post1);
relation.remove(post2);
user.save();
You can also pass in an array of AV.Object to add and remove:


relation.add([post1, post2, post3]);
user.save();
By default, the list of objects in this relation are not downloaded. You can get a list of the posts that a user likes by using the AVQuery returned by query. The code looks like:


relation.query().find({
  success: function(list) {
    // list contains the posts that the current user likes.
  }
});
If you want only a subset of the Posts, you can add extra constraints to the AVQuery returned by query like this:


var query = relation.query();
query.equalTo("title", "I'm Hungry");
query.find({
  success:function(list) {
    // list contains post liked by the current user which have the title "I'm Hungry".
  }
});
For more details on AVQuery, please look at the query portion of this guide. an AVRelation behaves similar to an array of AV.Object for querying purposes, so any query you can do on an array of objects, you can do on an AVRelation.

#### `{{relationObjectName}}` (Deprecated)

{{ docs.alert("以下文档仅供还在使用 Relation 的开发者做参考。对关联数据进行查询、排序等复杂操作，请使用 [中间表](relation-guide.html#使用中间表实现多对多关系_推荐_)。") }}

对象可以与其他对象相联系。如前面所述，我们可以把一个 `{{baseObjectName}}` 的实例 A，当成另一个 `{{baseObjectName}}` 实例 B 的属性值保存起来。这可以解决数据之间一对一或者一对多的关系映射，就像关系型数据库中的主外键关系一样。

例如，一个 TodoFolder 包含多个 Todo，可以用如下代码实现：

{% block code_relation_todoFolder_one_to_many_todo %}{% endblock %}

#### Pointer
Pointer 只是个描述并没有具象的类与之对应，它与 `{{relationObjectName}}` 不一样的地方在于：`{{relationObjectName}}` 是在**一对多**的「一」这一方（上述代码中的一指 TodoFolder）保存一个 `{{relationObjectName}}` 属性，这个属性实际上保存的是对被关联数据**多**的这一方（上述代码中这个多指 Todo）的一个 Pointer 的集合。而反过来，Cloud storage 也支持在「多」的这一方保存一个指向「一」的这一方的 Pointer，这样也可以实现**一对多**的关系。

简单的说， Pointer 就是一个外键的指针，只是在 LeanCloud Dashboard做了显示优化。

现在有一个新的需求：用户可以分享自己的 TodoFolder 到广场上，而其他用户看见可以给与评论，比如某玩家分享了自己想买的游戏列表（TodoFolder 包含多个游戏名字），而我们用 Comment 对象来保存其他用户的评论以及是否点赞等相关信息，代码如下：

{% block code_pointer_comment_one_to_many_todoFolder %}{% endblock %}

##### 获取 Pointer 对象

当 Todo 拥有一个字段叫做 TodoFolder 的 Pointer 类型的属性，在获取 Todo 的对象的同时，想一并把被关联的 TodoFolder 也拉取到本地：

{% block code_pointer_include_todoFolder %}{% endblock %}

更多内容可参考 [关联数据查询](relation-guide.html#Pointers_查询)。

#### GeoPoint
地理位置是一个特殊的数据类型，Cloud storage 封装了 `{{geoPointObjectName}}` 来实现storage以及相关的查询。

首先要创建一个 `{{geoPointObjectName}}` 对象。例如，创建一个北纬 39.9 度、东经 116.4 度的 `{{geoPointObjectName}}` 对象（LeanCloud 北京办公室所在地）：

{% block code_create_geoPoint %}{% endblock %}

假如，添加一条 Todo 的时候为该 Todo 添加一个地理位置信息，以表示创建时所在的位置：

{% block code_use_geoPoint %}{% endblock %}

同时请参考 [地理位置查询](#地理位置查询)。

{% block text_deserialize_and_serialize %}

### Serialization and Deserilization
在实际的开发中，把 `{{baseObjectName}}` 当做参数传递的时候，会涉及到复杂对象的拷贝的问题，因此 `{{baseObjectName}}` 也提供了序列化和反序列化的方法：

序列化：
{% block code_serialize_baseObject_to_string %}{% endblock %}

反序列化：
{% block code_deserialize_string_to_baseObject %}{% endblock %}

{% endblock %}

{% block object_extra %}{% endblock %}

{% block text_data_protocol %}

### Data Protocol
很多开发者在使用 Cloud storage 初期都会产生疑惑：客户端的数据类型是如何被云端识别的？
因此，我们有必要重点介绍一下 Cloud storage 的数据协议。

先从一个简单的日期类型入手，比如在 {{platform_name}} 中，默认的日期类型是 `{{dateType}}`，下面会详细讲解一个
 `{{dateType}}` 是如何被云端正确的按照日期格式storage的。

为一个普通的 `{{baseObjectName}}` 的设置一个 `{{dateType}}` 的属性，然后调用保存的接口：

{% block code_data_protocol_save_date %}{% endblock %}

{{sdk_name}} 在真正调用保存接口之前，会自动的调用一次序列化的方法，将 `{{dateType}}` 类型的数据，转化为如下格式的数据：

```json
{
  "__type": "Date",
  "iso": "2015-11-21T18:02:52.249Z"
}
```

然后发送给云端，云端会自动进行反序列化，这样自然就知道这个数据类型是日期，然后按照传过来的有效值进行storage。因此，开发者在进阶开发的阶段，最好是能掌握 Cloud storage 的数据协议。如下表介绍的就是一些默认的数据类型被序列化之后的格式：

{% block table_data_protocol %}

类型 | 序列化之后的格式|
---|---
`{{dateType}}` | `{"__type": "Date","iso": "2015-11-21T18:02:52.249Z"}`
`{{byteType}}` |  `{"__type": "Bytes","base64":"utf-8-encoded-string}"`
`Pointer` |`{"__type":"Pointer","className":"Todo","objectId":"55a39634e4b0ed48f0c1845c"}`
`{{relationObjectName}}`| `{"__type": "Relation","className": "Todo"}`
{% endblock %}

{% endblock %}

{% block text_LCType_convert %}
{% endblock %}
{% block module_file %}
## Files

AVFile lets you store application files in the cloud that would otherwise be too large or cumbersome to fit into a regular AV.Object. The most common use case is storing images, but you can also use it for documents, videos, music, and any other binary data (up to 10 megabytes).

Getting started with AVFile is easy. There are a couple of ways to create a file. The first is with a base64-encoded String.

文件storage也是数据storage的一种方式，图像、音频、视频、通用文件等等都是数据的载体。很多开发者也习惯把复杂对象序列化之后保存成文件，比如 JSON 或 XML 文件。文件storage在 Cloud storage 中被单独封装成一个 `{{fileObjectName}}` 来实现文件的上传、下载等操作。

Alternatively, you can create a file from an array of byte values:

LeanCloud will auto-detect the type of file you are uploading based on the file extension, but you can specify the Content-Type with a third parameter:


var file = new AVFile("myfile.zzz", fileData, "image/png");
But most commonly for HTML5 apps, you'll want to use an html form with a file upload control. On modern browsers, this is easy. Create a file input tag which allows the user to pick a file from their local drive to upload:


<input type="file" id="profilePhotoFileUpload">
Then, in a click handler or other function, get a reference to that file:


var fileUploadControl = $("#profilePhotoFileUpload")[0];
if (fileUploadControl.files.length > 0) {
  var file = fileUploadControl.files[0];
  var name = "photo.jpg";

  var LeanCloudFile = new AVFile(name, file);
}


LeanCloudFile.save().then(function() {
  // The file has been saved to AV
}, function(error) {
  // The file either could not be read, or could not be saved to AV
});
Finally, after the save completes, you can associate an AVFile with an AV.Object just like any other piece of data:


var jobApplication = new AV.Object("JobApplication");
jobApplication.set("applicantName", "Joe Smith");
jobApplication.set("applicantResumeFile", LeanCloudFile);
jobApplication.save();


### Uploading Files

文件上传是指开发者调用接口将文件storage在云端，并且返回文件最终的 URL 的操作。

文件上传成功后会在系统表 `_File` 中生成一条记录，**此后该记录无法被再次修改**，包括 [metaData 字段](#文件元数据) 中的数据。所以如需更新该文件的记录内容，只能重新上传文件，得到新的 id 和 URL。

如果 `_File` 表打开了 [删除权限](#删除)，该记录才可以被删除。

{% block text_create_avfile_by_stream_data %}
#### Creating a file from stream
`{{fileObjectName}}` 支持图片、视频、音乐等常见的文件类型，以及其他任何二进制数据，在构建的时候，传入对应的数据流即可：

{% block code_create_avfile_by_stream_data %}{% endblock %}

上例将文件命名为 `resume.txt`，这里需要注意两点：

Notice in this example that we give the file a name of photo.jpg. There's two things to note here:

You don't need to worry about filename collisions. Each upload gets a unique identifier so there's no problem with uploading multiple files named photo.jpg.
It's important that you give a name to the file that has a file extension. This lets LeanCloud figure out the file type and handle it accordingly. So, if you're storing PNG images, make sure your filename ends with .png.

Next you'll want to save the file up to the cloud. As with AV.Object, there are many variants of the save method you can use depending on what sort of callback and error handling suits you.


- 不必担心文件名冲突。每一个上传的文件都有惟一的 ID，所以即使上传多个文件名为 `resume.txt` 的文件也不会有问题。
- 给文件添加扩展名非常重要。云端通过扩展名来判断文件类型，以便正确处理文件。所以要将一张 PNG 图片存到 `{{fileObjectName}}` 中，要确保使用 `.png` 扩展名。
{% endblock %}


{% block text_create_avfile_from_local_path %}
#### 从本地路径构建文件
大多数的客户端应用程序都会跟本地文件系统产生交互，常用的操作就是读取本地文件，如下代码可以实现使用本地文件路径构建一个 `{{fileObjectName}}`：

{% block code_create_avfile_from_local_path %}{% endblock %}

{% endblock %}

{% block text_create_avfile_from_url %}
#### 从网络路径构建文件
从一个已知的 URL 构建文件也是很多应用的需求。例如，从网页上拷贝了一个图像的链接，代码如下：

{% block code_create_avfile_from_url %}{% endblock %}

{% endblock %}

[从本地路径构建文件](#从本地路径构建文件) 会<u>产生实际上传的流量</u>，并且文件最后是存在云端，而 [从网络路径构建文件](#从网络路径构建文件) 的文件实体并不storage在云端，只是会把文件的物理地址作为一个字符串保存在云端。

{% block text_upload_file %}
#### 执行上传
上传的操作调用方法如下：

{% block code_upload_file %}{% endblock %}
{% endblock %}

{% block text_upload_file_with_progress %}
#### 上传进度监听
一般来说，上传文件都会有一个上传进度条显示用以提高用户体验：

{% block code_upload_file_with_progress %}{% endblock %}

{% endblock %}

{% block text_download_file_with_progress %}
### Retrieving File Contents/Download

How to best retrieve the file contents back depends on the context of your application. Because of cross-domain request issues, it's best if you can make the browser do the work for you. Typically, that means rendering the file's URL into the DOM. Here we render an uploaded profile photo on a page with jQuery:

客户端 SDK 接口可以下载文件并把它缓存起来，只要文件的 URL 不变，那么一次下载成功之后，就不会再重复下载，目的是为了减少客户端的流量。

{% block code_download_file %}{% endblock %}
{% block text_download_progress %}请注意代码中**下载进度**数据的读取。{% endblock %}

{% endblock %}
{% if node !='qcloud' %}
### Image Thumbnail

保存图像时，如果想在下载原图之前先得到缩略图，方法如下：

{% block code_file_image_thumbnail %}{% endblock %}

<div class="callout callout-info">图片最大不超过 **20 MB** 才可以获取缩略图。</div>

<div class="callout callout-danger">图片缩略图只支持华北节点的应用，华东和北美节点不支持。</div>

{% endif %}
### File Metadata

`{{fileObjectName}}` 的 `metaData` 属性，可以用来保存和获取该文件对象的元数据信息。metaData 一旦保存到云端就**无法再次修改**。 

{% block code_file_metadata %}{% endblock %}

{% block text_file_query %}{% endblock %}

### Deleting an AVFile

You can delete files that are referenced by objects using the REST API. You will need to provide the master key in order to be allowed to delete a file.

If your files are not referenced by any object in your app, it is not possible to delete them through the REST API. You may request a cleanup of unused files in your app's Settings page. Keep in mind that doing so may break functionality which depended on accessing unreferenced files through their URL property. Files that are currently associated with an object will not be affected.

当文件较多时，要把一些不需要的文件从云端删除：

<div class="callout callout-danger">默认情况下，文件的删除权限是关闭的，需要进入 {% if node == 'qcloud' %}**Dashboard** > **storage** > `_File`{% else %}[Dashboard > Data > **`_File`**](/data.html?appid={{appid}}#/_File){% endif %}，选择菜单 **其他** > **权限设置** > **delete** 来开启。</div>

{% block code_file_delete %}{% endblock %}

{% block code_cache_operations_file %}{% endblock %}

{% block text_https_access_for_ios9 %}{% endblock %}

### CDN

{{ data.cdn(true) }}

{% endblock %}

{# 2017-11-09 the following block doesn't apply to swift, php, python #}
{% if segment_code === 'objc' or segment_code === 'java' or segment_code === 'js' or segment_code === 'android' %}
### 常见的文件使用场景

#### 文件被其他对象关联

解决方案：将 AVFile 当做 `Pointer` 类型关联 AV.Object 对象的一个字段:

{% block file_as_avatar %}{% endblock %}

查询的时候需要额外的 include 一下:

{% block query_file_as_avatar %}{% endblock %}
{% endif %}

## Queries
`{{baseQueryClassName}}` 是构建针对 `{{baseObjectName}}` 查询的基础类。{{query_result_limit}}

### 示例数据结构

熟悉本文所使用的相关数据表结构将有助于更好地理解后面的内容。

![](images/todo-schema.svg)

#### Todo（待办事项）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `content` | String | 事项的详细内容 |
| `images` | AVFile | 与事项相关的图片 |
| `location` | String | 处理该事项的地点 |
| `priority` | Number | 0 优先级最高，最迫切需要完成。 |
| `reminders` | Array | 设置提醒日期和时间 |
| `status` | Number | 0 未完成，1 已完成 |
| `title` | String | 事项的标题（简短描述） |
| `views` | Number | 该事项被浏览过的次数 |
| `whereCreated` | AVGeoPoint | 该事项被创建时的地理定位 |

#### TodoFolder（待办事项的分组）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `containedTodos` | Relation | 所包含的 Todo，与表 `Todo` 相关联。 |
| `name` | String | 分组的名称，如家庭、会议。 |
| `owner` | Pointer | 分组的所有者或创建人，指向表 `_User` |
| `priority` | Number | 该分组的优先级别，0 优先级最高。 |
| `tags` | Relation | 标签，与表 `Tag` 相关联。 |

#### Comment（待办事项分组的评论）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `content` | String | 评论的内容 |
| `likes` | Number | 点了赞就是 1，点了不喜欢为 -1，没有做任何操作就为 0（默认）。 |
| `targetTodoFolder` | Pointer | 相关联的待办事项分组，指向表 `TodoFolder` 的 objectId |

#### Tag（待办事项分组的标签）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `name` | String | 标签的名称，如今日必做、老婆吩咐、十分重要等。 |
| `targetTodoFolder` | Pointer | 相关联的待办事项分组，指向表 `TodoFolder` 的 objectId |

{% block text_avquery_constructors %}
We've already seen how an AVQuery with get can retrieve a single AV.Object from AV There are many other ways to retrieve data with AVQuery - you can retrieve many objects at once, put conditions on the objects you wish to retrieve, and more.

Basic Queries
In many cases, get isn't powerful enough to specify which objects you want to retrieve. AVQuery offers different ways to retrieve a list of objects rather than just a single object.

The general pattern is to create an AVQuery, put conditions on it, and then retrieve an Array of matching AV.Objects using find. For example, to retrieve the scores that have a particular playerName, use the equalTo method to constrain the value for a key.



### 创建查询实例
{% block code_create_query_by_className %}{% endblock %}

{% endblock %}

最基础的用法是根据 objectId 来查询对象：

{{ code_get_todo_by_objectId() }}

### Query Constraints

{% block table_logic_comparison_in_query %}{% endblock %}

利用上述表格介绍的逻辑操作的接口，我们可以很快地构建条件查询。

例如，查询优先级小于 2 的所有 Todo ：

{% block code_query_lessThan %}{% endblock %}

<div class="callout callout-info">{{query_result_limit}}</div>

以上逻辑用 SQL 语句表达为 `select * from Todo where priority < 2`。Cloud storage 也支持使用这种传统的 SQL 语句查询。具体使用方法请移步至 [CQL 查询](#CQL_查询)。

查询优先级大于等于 2 的 Todo：

{% block code_query_greaterThanOrEqualTo %}{% endblock %}

There are several ways to put constraints on the objects found by an AVQuery. You can filter out objects with a particular key-value pair with notEqualTo:


query.notEqualTo("playerName", "Michael Yabuti");
You can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.


query.notEqualTo("playerName", "Michael Yabuti");
query.greaterThan("playerAge", 18);
You can limit the number of results by setting limit. By default, results are limited to 100.

When adding constraints, you want to pay attention and design efficient queries.

You can use skip and limit to page through results and load the data as is needed. The query limit is 100 by default:

query.limit(10); // limit to at most 10 results
If you want exactly one result, a more convenient alternative may be to use first instead of using find.


var GameScore = AV.Object.extend("GameScore");
var query = new AVQuery(GameScore);
query.equalTo("playerEmail", "dstemkoski@example.com");
query.first({
  success: function(object) {
    // Successfully retrieved the object.
  },
  error: function(error) {
    alert("Error: " + error.code + " " + error.message);
  }
});
You can skip the first results by setting skip. In the old LeanCloud hosted backend, the maximum skip value was 10,000, but LeanCloud Server removed that constraint. This can be useful for pagination:


query.skip(10); // skip the first 10 results
For sortable types like numbers and strings, you can control the order in which results are returned:


If you want to retrieve objects matching any of the values in a list of values, you can use containedIn, providing an array of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve scores made by any player in a particular list:


// Finds scores from any of Jonathan, Dario, or Shawn
query.containedIn("playerName",
                  ["Jonathan Walsh", "Dario Wunsch", "Shawn Simon"]);
If you want to retrieve objects that do not match any of several values you can use notContainedIn, providing an array of acceptable values. For example if you want to retrieve scores from players besides those in a list:


// Finds scores from anyone who is neither Jonathan, Dario, nor Shawn
query.notContainedIn("playerName",
                     ["Jonathan Walsh", "Dario Wunsch", "Shawn Simon"]);
If you want to retrieve objects that have a particular key set, you can use exists. Conversely, if you want to retrieve objects without a particular key set, you can use doesNotExist.


// Finds objects that have the score set
query.exists("score");

// Finds objects that don't have the score set
query.doesNotExist("score");
You can use the matchesKeyInQuery method to get objects where a key matches the value of a key in a set of objects resulting from another query. For example, if you have a class containing sports teams and you store a user's hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records. The query would look like:


var Team = AV.Object.extend("Team");
var teamQuery = new AVQuery(Team);
teamQuery.greaterThan("winPct", 0.5);
var userQuery = new AVQuery(AVUser);
userQuery.matchesKeyInQuery("hometown", "city", teamQuery);
userQuery.find({
  success: function(results) {
    // results has the list of users with a hometown team with a winning record
  }
});
Conversely, to get objects where a key does not match the value of a key in a set of objects resulting from another query, use doesNotMatchKeyInQuery. For example, to find users whose hometown teams have losing records:

You can restrict the fields returned by calling select with a list of keys. To retrieve documents that contain only the score and playerName fields (and also special built-in fields such as objectId, createdAt, and updatedAt):


var GameScore = AV.Object.extend("GameScore");
var query = new AVQuery(GameScore);
query.select("score", "playerName");
query.find().then(function(results) {
  // each of results will only have the selected fields available.
});
The remaining fields can be fetched later by calling fetch on the returned objects:

#### 多个查询条件

当多个查询条件并存时，它们之间默认为 AND 关系，即查询只返回满足了全部条件的结果。建立 OR 关系则需要使用 [组合查询](#组合查询)。

You can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.

在**简单查询**中，如果对一个对象的**同一属性**设置多个条件，那么先前的条件会被覆盖，查询只返回满足最后一个条件的结果。例如要找出优先级为 0 和 1 的所有 Todo，错误写法是：

{% block code_priority_equalTo_zero_and_one_wrong_example %}{% endblock %}

正确作法是使用 [组合查询 · OR 关系](#OR_查询) 来构建这种条件。

### Queries on String Values

**前缀查询**类似于 SQL 的 `LIKE 'keyword%'` 条件。因为支持索引，所以该操作对于大数据集也很高效。

Use startsWith to restrict to string values that start with a particular string. Similar to a MySQL LIKE operator, this is indexed so it is efficient for large datasets:

{% block code_query_whereHasPrefix %}{% endblock %}

**包含查询**类似于 SQL 的 `LIKE '%keyword%'` 条件，比如查询标题包含「李总」的 Todo：

The above example will match any BarbecueSauce objects where the value in the “name” String key starts with “Big Daddy's”. For example, both “Big Daddy's” and “Big Daddy's BBQ” will match, but “big daddy's” or “BBQ Sauce: Big Daddy's” will not.

Queries that have regular expression constraints are very expensive, especially for classes with over 100,000 records. LeanCloud restricts how many such operations can be run on a particular app at any given time.

{% block code_query_with_contains_keyword %}whereContains{% endblock %}

**不包含查询**可以使用**正则匹配查询**的方式来实现。例如，查询标题不包含「机票」的 Todo：

This looks for data that starts with the given string. This query will use the backend index, so it will be faster even for large datasets.

As a best practice, when you use regular expression constraints, you'll want to ensure that other constraints in the query reduce the result set to the order of hundreds of objects to make the query efficient. If you must use the matches or contains constraints for legacy reasons, then use case sensitive, anchored queries where possible, for example:

Most of the use cases around using regular expressions involve implementing search. A more performant way of implementing search is detailed later

{% block code_query_with_not_contains_keyword_using_regex %}正则表达式{% endblock %}

<div class="callout callout-info">正则匹配查询**只适用于**字符串类型的数据。</div>

但是基于正则的模糊查询有两个缺点：

- 当数据量逐步增大后，查询效率将越来越低。
- 没有文本相关性排序

因此我们推荐使用 [应用内搜索](#应用内搜索) 功能。它基于搜索引擎技术构建，提供更强大的搜索功能。

You can use fullText for efficient search capabilities. Text indexes are automatically created for you. Your strings are turned into tokens for fast searching.

Note: Full Text Search can be resource intensive. Ensure the cost of using indexes is worth the benefit, see storage requirements & performance costs of text indexes..


### Queries on Array Values

For keys with an array type, you can find objects where the key's array value contains 2 by:

You can also find objects where the key's array value contains each of the elements 2, 3, and 4 with the following:

当一个对象有一个属性是数组的时候，针对数组的元数据查询可以有多种方式。例如，在 [数组](#更新数组) 一节中我们为 Todo 设置了 reminders 属性，它就是一个日期数组，现在我们需要查询所有在 8:30 会响起闹钟的 Todo 对象：

{% block code_query_array_contains_using_equalsTo %}{% endblock %}

查询包含 8:30 和 9:30 这两个时间点响起闹钟的 Todo：

{% block code_query_array_contains_all %}{% endblock %}

注意这里是包含关系，假如有一个 Todo 会在 8:30、9:30 和 10:30 响起闹钟，它仍然是会被查询出来的。

查询「全不包含」的情况：
If you want to retrieve objects matching any of the values in a list of values, you can use containedIn, providing an array of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve scores made by any player in a particular list:
{% block code_query_with_not_contains_keyword %}notContainedIn{% endblock %}

If you want to retrieve objects that do not match any of several values you can use notContainedIn, providing an array of acceptable values. For example if you want to retrieve scores from players besides those in a list:

### 空值查询

假设用户可以有选择地为 Todo 上传图片来做标注，要想找出那些已有图片的 Todo：

{% block code_query_where_keys_exist %}{% endblock %}

### Relational Queries
There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular AV.Object, you can use equalTo just like for other data types. For example, if each Comment has a Post object in its post field, you can fetch comments for a particular Post:


// Assume AV.Object myPost was previously created.
var query = new AVQuery(Comment);
query.equalTo("post", myPost);
query.find({
  success: function(comments) {
    // comments now contains the comments for myPost
  }
});
If you want to retrieve objects where a field contains an AV.Object that matches a different query, you can use matchesQuery. In order to find comments for posts containing images, you can do:


var Post = AV.Object.extend("Post");
var Comment = AV.Object.extend("Comment");
var innerQuery = new AVQuery(Post);
innerQuery.exists("image");
var query = new AVQuery(Comment);
query.matchesQuery("post", innerQuery);
query.find({
  success: function(comments) {
    // comments now contains the comments for posts with images.
  }
});
If you want to retrieve objects where a field contains an AV.Object that does not match a different query, you can use doesNotMatchQuery. In order to find comments for posts without images, you can do:


var Post = AV.Object.extend("Post");
var Comment = AV.Object.extend("Comment");
var innerQuery = new AVQuery(Post);
innerQuery.exists("image");
var query = new AVQuery(Comment);
query.doesNotMatchQuery("post", innerQuery);
query.find({
  success: function(comments) {
    // comments now contains the comments for posts without images.
  }
});
You can also do relational queries by objectId:


var post = new Post();
post.id = "1zEcyElZ80";
query.equalTo("post", post);
In some situations, you want to return multiple types of related objects in one query. You can do this with the include method. For example, let's say you are retrieving the last ten comments, and you want to retrieve their related posts at the same time:


var query = new AVQuery(Comment);

// Retrieve the most recent ones
query.descending("createdAt");

// Only retrieve the last ten
query.limit(10);

// Include the post data with each comment
query.include("post");

query.find({
  success: function(comments) {
    // Comments now contains the last ten comments, and the "post" field
    // has been populated. For example:
    for (var i = 0; i < comments.length; i++) {
      // This does not require a network access.
      var post = comments[i].get("post");
    }
  }
});
You can also do multi level includes using dot notation. If you wanted to include the post for a comment and the post's author as well you can do:


query.include(["post.author"]);
You can issue a query with multiple fields included by calling include multiple times. This functionality also works with AVQuery helpers like first and get.
关联数据查询也可以通俗地理解为关系查询，关系查询在传统型数据库的使用中是很常见的需求，因此我们也提供了相关的接口来满足开发者针对关联数据的查询。

首先，我们需要明确关系的storage方式，再来确定对应的查询方式。

#### Pointer 查询
基于在 [Pointer](#Pointer) 小节介绍的storage方式：每一个 Comment 都会有一个 TodoFolder 与之对应，用以表示 Comment 属于哪个 TodoFolder。现在我已知一个 TodoFolder，想查询所有的 Comnent 对象，可以使用如下代码：

{% block code_query_comment_by_todoFolder %}{% endblock %}

#### `{{relationObjectName}}` 查询
假如用户可以给 TodoFolder 增加一个 Tag 选项，用以表示它的标签，而为了以后拓展 Tag 的属性，就新建了一个 Tag 对象，如下代码是创建 Tag 对象：

{% block code_create_tag_object %}{% endblock %}

而 Tag 的意义在于一个 TodoFolder 可以拥有多个 Tag，比如「家庭」（TodoFolder） 拥有的 Tag 可以是：今日必做、老婆吩咐、十分重要。实现创建「家庭」这个 TodoFolder 的代码如下：

{% block code_create_family_with_tag %}{% endblock %}

查询一个 TodoFolder 的所有 Tag 的方式如下：

{% block code_query_tag_for_todoFolder %}{% endblock %}

反过来，现在已知一个 Tag，要查询有多少个 TodoFolder 是拥有这个 Tag 的，可以使用如下代码查询：

{% block code_query_todoFolder_with_tag %}{% endblock %}

关于关联数据的建模是一个复杂的过程，很多开发者因为在storage方式上的选择失误导致最后构建查询的时候难以下手，不但客户端代码冗余复杂，而且查询效率低，为了解决这个问题，我们专门针对关联数据的建模推出了一个详细的文档予以介绍，详情请阅读《[数据模型设计指南](relation-guide.html)》。

#### 关联属性查询
正如在 [Pointer](#Pointer) 中保存 Comment 的 targetTodoFolder 属性一样，假如查询到了一些 Comment 对象，想要一并查询出每一条 Comment 对应的 TodoFolder 对象的时候，可以加上 include 关键字查询条件。同理，假如 TodoFolder 表里还有 pointer 型字段 targetAVUser 时，再加上一个递进的查询条件，形如 include(b.c)，即可一并查询出每一条 TodoFolder 对应的 AVUser 对象。代码如下：

{% block code_query_comment_include_todoFolder %}{% endblock %}

此外需要格外注意的是，假设对象有一个 Array 类型的字段 `todoArray` 内部是 Pointer 类型：
```
[pointer1, pointer2, pointer3]
```
可以用 include 方法获取数组中的 pointer 数据，例如：

```objc
[query includeKey:@"todoArray"];
```
```java
query.include("todoArray");
```
```js
query.include('todoArray');
```

但是 Array 类型的 include 操作只支持到第一层，不支持 `include(b.c)` 这种递进关联查询。

`select` 也具备使用 dot 符号 `.` 来进行级联操作：

```objc
[query selectKeys:@"targetTodoFolder.targetAVUser.username"];
```
```java
query.selectKeys(Arrays.asList("targetTodoFolder.targetAVUser.username"));
```
```js
query.select(['targetTodoFolder.targetAVUser.username']);
```

#### 内嵌查询

There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular AV.Object, you can use equalTo just like for other data types. For example, if each Comment has a Post object in its post field, you can fetch comments for a particular Post:

查询点赞超过 20 次的 TodoFolder 的 Comment 评论（注意查询针对的是 [Comment](#Comment_待办事项分组的评论_)），使用内嵌查询接口就可以通过一次查询来达到目的。

{% block code_query_comment_match_query_todoFolder %}{% endblock %}

与普通查询一样，内嵌查询默认也最多返回 100 条记录，想修改这一默认请参考 [限定结果返回数量](#限定返回数量)。
Same as a basic query, by default, results are limited to 100.

**如果所有返回的记录没有匹配到外层的查询条件，那么整个查询也查不到结果**。例如：


{{ data.innerQueryLimitation(description="", skip="[skip](#跳过数量)") }}

### Aggregate
### Distinct

### Geo Queries

LeanCloud allows you to associate real-world latitude and longitude coordinates with an object. Adding an AVGeoPoint to an AV.Object allows queries to take into account the proximity of an object to a reference point. This allows you to easily do things like find out what user is closest to another user or which places are closest to a user.

地理位置查询是较为特殊的查询，一般来说，常用的业务场景是查询距离 xx 米之内的某个位置或者是某个建筑物，甚至是以手机为圆心，查找方圆多少范围内餐厅等等。Cloud storage 提供了一系列的方法来实现针对地理位置的查询。

Now that you have a bunch of objects with spatial coordinates, it would be nice to find out which objects are closest to a point. This can be done by adding another restriction to AVQuery using near. Getting a list of ten places that are closest to a user may look something like:

At this point placesObjects will be an array of objects ordered by distance (nearest to farthest) from userGeoPoint. Note that if an additional ascending()/descending() order-by constraint is applied, it will take precedence over the distance ordering.

To limit the results using distance, check out withinMiles, withinKilometers, and withinRadians.

It's also possible to query for the set of objects that are contained within a particular area. To find the objects in a rectangular bounding box, add the withinGeoBox restriction to your AVQuery.

#### 查询位置附近的对象

You can query for whether an object lies within or on a polygon of AVGeoPoint (minimum 3 points):

Todo 的 `whereCreated`（创建 Todo 时的位置）是一个 `{{geoPointObjectName}}` 对象，现在已知了一个地理位置，现在要查询 `whereCreated` 靠近这个位置的 Todo 对象可以使用如下代码：

{% block code_query_geoPoint_near %}{% endblock %}

#### 查询指定范围内的对象
You can also query for whether an object AVPolygon contains an AVGeoPoint:

要查找指定距离范围内的数据，可使用 `whereWithinKilometers` 、 `whereWithinMiles` 或 `whereWithinRadians` 方法。
例如，我要查询距离指定位置，2 千米范围内的 Todo：

{% block code_query_geoPoint_within %}{% endblock %}

#### 注意事项

Caveats
At the moment there are a couple of things to watch out for:

Each AV.Object class may only have one key with an AVGeoPoint object.
Using the near constraint will also limit results to within 100 miles.
Points should not equal or exceed the extreme ends of the ranges. Latitude should not be -90.0 or 90.0. Longitude should not be -180.0 or 180.0. Attempting to set latitude or longitude out of bounds will cause an error.

使用地理位置需要注意以下方面：

* 每个 `{{baseObjectName}}` 数据对象中只能有一个 `{{geoPointObjectName}}` 对象的属性。
* 地理位置的点不能超过规定的范围。纬度的范围应该是在 `-90.0` 到 `90.0` 之间，经度的范围应该是在 `-180.0` 到 `180.0` 之间。如果添加的经纬度超出了以上范围，将导致程序错误。
{% block text_platform_geoPoint_notice %}{% endblock %}

### Compound Queries
For more complex queries you might need compound queries. A compound query is a logical combination (e. g. “and” or “or”) of sub queries.

Note that we do not support GeoPoint or non-filtering constraints (e.g. near, withinGeoBox, limit, skip, ascending/descending, include) in the subqueries of the compound query.

组合查询就是把诸多查询条件合并成一个查询，再交给 SDK 去云端查询。方式有两种：OR 和 AND。

#### OR-ed Query Constraints
If you want to find objects that match one of several queries, you can use AVQuery.or method to construct a query that is an OR of the queries passed in. For instance if you want to find players who either have a lot of wins or a few wins, you can do:
OR 操作表示多个查询条件符合其中任意一个即可。 例如，查询优先级是大于等于 3 或者已经完成了的 Todo：

{% block code_query_with_or %}{% endblock %}

**注意：OR 查询中，子查询中不能包含地理位置相关的查询。**

#### AND-ed Query Constraints

If you want to find objects that match all conditions, you normally would use just one query. You can add additional constraints to the newly created AVQuery that act as an ‘and' operator.

Sometimes the world is more complex than this simple example and you may need a compound query of sub queries. You can use AVQuery.and method to construct a query that is an AND of the queries passed in. For instance if you want to find users in the age of 16 or 18 who have either no friends or at least 2 friends, you can do:

AND 操作将满足了所有查询条件的对象返回给客户端。例如，找到创建于 `2016-11-13` 至 `2016-12-02` 之间的 Todo：

{% block code_query_with_and %}{% endblock %}

可以对新创建的 `{{baseQueryClassName}}` 添加额外的约束，多个约束将以 AND 运算符来联接。

### Counting and Sorting Objects

Note: In the old LeanCloud hosted backend, count queries were rate limited to a maximum of 160 requests per minute. They also returned inaccurate results for classes with more than 1,000 objects. But, LeanCloud Server has removed both constraints and can count objects well above 1,000.

If you just need to count how many objects match a query, but you do not need to retrieve all the objects that match, you can use count instead of find. For example, to count how many games have been played by a particular player:

#### 获取第一条结果

If you want exactly one result, a more convenient alternative may be to use first instead of using find.

例如很多应用场景下，只要获取满足条件的一个结果即可，例如获取满足条件的第一条 Todo：

{% block code_query_find_first_object %}{% endblock %}

#### 限定返回数量

You can limit the number of results by setting limit. By default, results are limited to 100. In the old LeanCloud hosted backend, the maximum limit was 1,000, but LeanCloud Server removed that constraint:

为了防止查询出来的结果过大，云端默认针对查询结果有一个数量限制，即 `limit`，它的默认值是 100。比如一个查询会得到 10000 个对象，那么一次查询只会返回符合条件的 100 个结果。`limit` 允许取值范围是 1 ~ 1000。例如设置返回 10 条结果：

{% block code_set_query_limit %}{% endblock %}

#### 跳过数量

You can skip the first results by setting skip. In the old LeanCloud hosted backend, the maximum skip value was 10,000, but LeanCloud Server removed that constraint. This can be useful for pagination:

设置 skip 这个参数可以告知云端本次查询要跳过多少个结果。将 skip 与 limit 搭配使用可以实现翻页效果，这在客户端做列表展现时，特别是在数据量庞大的情况下适合使用。例如，在翻页中每页显示数量为 10，要获取第 3 页的对象：

{% block code_set_skip_for_pager %}{% endblock %}

上述方法的执行效率比较低，因此不建议广泛使用。**建议选用 `{{createdAtName}}` 或者 `{{updatedAtName}}` 这类的时间戳进行分段查询**（[示例](#AND_查询)）。

#### 返回指定属性/字段
通常列表展现的时候并不是需要展现某一个对象的所有属性，例如，Todo 这个对象列表一般展现的是 title 以及 content，在设置查询时可以告知云端需要返回的属性或字段有哪些，这样既满足需求又节省流量，还可以提高一部分的性能：

{% block code_query_select_keys %}{% endblock %}

所指定的属性或字段也支持 Pointer 类型。例如，获取 Todo 这个对象的所有者信息（owner 属性，Pointer 类型），仅展示这个所有者的 username：

{% block code_query_select_pointer_keys %}{% endblock %}

#### 统计总数量
通常用户在执行完搜索后，结果页面总会显示出诸如「搜索到符合条件的结果有 1020 条」这样的信息。例如，查询一下今天一共完成了多少条 Todo：

{% block code_query_count %}{% endblock %}

#### Sorting Objects
For sortable types like numbers and strings, you can control the order in which results are returned:

对于数字、字符串、日期类型的数据，可对其进行升序或降序排列。

{% block code_query_orderby %}{% endblock %}

一个查询可以附加多个排序条件，如按 priority 升序、createdAt 降序排列：

{% block code_query_orderby_on_multiple_keys %}{% endblock %}

<!-- #### 限定返回字段 -->

### Creating Queries with CQL
CQL 是 Cloud storage 独创的使用类似 SQL 语法来实现云端查询功能的语言，具有 SQL 开发经验的开发者可以方便地使用此接口实现查询。

分别找出 status = 1 的全部 Todo 结果，以及 priority = 0 的 Todo 的总数：

{% block code_query_by_cql %}{% endblock %}

通常查询语句会使用变量参数，为此我们提供了与 Java JDBC 所使用的 PreparedStatement 占位符查询相类似的语法结构。

查询 status = 0、priority = 1 的 Todo：

{% block code_query_by_cql_with_placeholder %}{% endblock %}

目前 CQL 已经支持数据的更新 update、插入 insert、删除 delete 等 SQL 语法，更多内容请参考 [CQL 详细指南](cql_guide.html)。

{% block text_query_cache_intro %}
### 缓存查询
缓存一些查询的结果到磁盘上，这可以让你在离线的时候，或者应用刚启动，网络请求还没有足够时间完成的时候可以展现一些数据给用户。当缓存占用了太多空间的时候，Cloud storage 会自动清空缓存。

默认情况下的查询不会使用缓存，除非你调用接口明确设置启用。例如，尝试从网络请求，如果网络不可用则从缓存数据中获取，可以这样设置：

{% block code_set_cache_policy %}{% endblock %}

#### 缓存策略
为了满足多变的需求，SDK 默认提供了以下几种缓存策略：

{% block table_cache_policy %}{% endblock %}

#### 缓存相关的操作
{% block code_cache_operation %}{% endblock %}

{% endblock %}
You are responsible for managing your database and maintaining indexes when using LeanCloud Server. If your data is not indexed, every query will have to go through the the entire data for a class to return a query result. On the other hand, if your data is indexed appropriately, the number of documents scanned to return a correct query result should be low.

The order of a query constraint's usefulness is:

Equal to
Contained In
Less than, Less than or Equal to, Greater than, Greater than or Equal to
Prefix string matches
Not equal to
Not contained in
Everything else
Take a look at the following query to retrieve GameScore objects:

### 查询性能优化

影响查询性能的因素很多。特别是当查询结果的数量超过 10 万，查询性能可能会显著下降或出现瓶颈。以下列举一些容易降低性能的查询方式，开发者可以据此进行有针对性的调整和优化，或尽量避免使用。

- 不等于和不包含查询（无法使用索引）
- 通配符在前面的字符串查询（无法使用索引）
- 有条件的 count（需要扫描所有数据）
- skip 跳过较多的行数（相当于需要先查出被跳过的那些行）
- 无索引的排序（另外除非复合索引同时覆盖了查询和排序，否则只有其中一个能使用索引）
- 无索引的查询（另外除非复合索引同时覆盖了所有条件，否则未覆盖到的条件无法使用索引，如果未覆盖的条件区分度较低将会扫描较多的数据）

{% block text_js_promise %}{% endblock %}

## Users
At the core of many apps, there is a notion of user accounts that lets users access their information in a secure manner. We provide a specialized user class called AVUser that automatically handles much of the functionality required for user account management.

With this class, you'll be able to add user account functionality in your app.

AVUser is a subclass of AV.Object, and has all the same features, such as flexible schema, automatic persistence, and a key value interface. All the methods that are on AV.Object also exist in AVUser. The difference is that AVUser has some special additions specific to user accounts.

用户系统几乎是每款应用都要加入的功能。除了基本的注册、登录和密码重置，移动端开发还会使用手机号一键登录{% if node != 'qcloud' and node != 'us' %}、短信验证码登录{% endif %}等功能。Cloud storage 提供了一系列接口来帮助开发者快速实现各种场景下的需求。

`{{userObjectName}}` 是用来描述一个用户的特殊对象，与之相关的数据都保存在 `_User` 数据表中。

### AVUser Properties

#### 默认属性
用户名、密码、邮箱是默认提供的三个属性，访问方式如下：

AVUser has several values that set it apart from AV.Object:

username: The username for the user (required).
password: The password for the user (required on signup).
email: The email address for the user (optional).
We'll go through each of these in detail as we run through the various use cases for users.

{% block code_get_user_properties %}{% endblock %}

请注意代码中，密码是仅仅是在注册的时候可以设置的属性（这部分代码可参照 [用户名和密码注册](#用户名和密码注册)），它在注册完成之后并不会保存在本地（SDK 不会以明文保存密码这种敏感数据），所以在登录之后，再访问密码这个字段是为**空的**。

#### 自定义属性

用户对象和普通对象一样也支持添加自定义属性。例如，为当前用户添加年龄属性 `age`：

{% block code_set_user_custom_properties %}{% endblock %}

#### 修改属性

很多开发者会有这样的疑问：「为什么我不能修改任意一个用户的属性？」

>因为很多时候，就算是开发者也不要轻易修改用户的基本信息，例如用户的手机号、社交账号等个人信息都比较敏感，应该由用户在 App 中自行修改。所以为了保证用户的数据仅在用户自己已登录的状态下才能修改，云端对所有针对 `{{userObjectName}}` 对象的数据操作都要做验证。

例如，先为当前用户增加一个 age 属性，保存后再更改它的值：

{% block code_update_user_custom_properties %}{% endblock %}

`{{userObjectName}}` 的自定义属性在使用上与 `{{baseObjectName}}` 没有本质区别。

### Signing Up

The first thing your app will do is probably ask the user to sign up. The following code illustrates a typical sign up:

{% block text_send_sms_code_for_loginOrSignup %}

This call will asynchronously create a new user in your LeanCloud App. Before it does this, it also checks to make sure that both the username and email are unique. Also, it securely hashes the password in the cloud using bcrypt. We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext.

Note that we used the signUp method, not the save method. New AVUsers should always be created using the signUp method. Subsequent updates to a user can be done by calling save.

If a signup isn't successful, you should read the error object that is returned. The most likely case is that the username or email has already been taken by another user. You should clearly communicate this to your users, and ask them try a different username.

You are free to use an email address as the username. Simply ask your users to enter their email, but fill it in the username property — AVUser will work as normal. We'll go over how this is handled in the reset password section.

{% if node=='qcloud' %}
<div class="callout callout-danger">注意：TAB 暂时未开放短信功能，所以所有与短信相关的 API 操作（如使用手机号进行注册）暂时不能调用。</div>
{% endif %}

{% if node != 'qcloud' and node != 'us' %}
#### 手机号码注册

一些应用为了提高首次使用的友好度，一般会允许用户浏览一些内容，直到用户发起了一些操作才会要求用户输入一个手机号，而云端会自动发送一条验证码的短信给用户的手机号，最后验证一下，完成一个用户注册并且登录的操作，例如很多团购类应用都有这种用户场景。

首先调用发送验证码的接口：

{% block code_send_sms_code_for_loginOrSignup %}{% endblock %}

然后在 UI 上给与用户输入验证码的输入框，用户点击登录的时候调用如下接口：

{% block code_verify_sms_code_for_loginOrSignup %}{% endblock %}

{% endif %}
{% endblock %}
#### 用户名和密码注册

采用「用户名 + 密码」注册时需要注意：密码是以明文方式通过 HTTPS 加密传输给云端，云端会以密文storage密码，并且我们的加密算法是无法通过所谓「彩虹表撞库」获取的，这一点请开发者放心。换言之，用户的密码只可能用户本人知道，开发者不论是通过Dashboard还是 API 都是无法获取。另外我们需要强调<u>在客户端，应用切勿再次对密码加密，这会导致重置密码等功能失效</u>。

例如，注册一个用户的示例代码如下（用户名 `Tom` 密码 `cat!@#123`）：

{% block code_user_signUp_with_username_and_password %}{% endblock %}

{% block text_using_async_methods %}
我们建议在可能的情况下尽量使用异步版本的方法，这样就不会影响到应用程序主 UI 线程的响应。
{% endblock %}

如果注册不成功，请检查一下返回的错误对象。最有可能的情况是用户名已经被另一个用户注册，错误代码 [202](error_code.html#_202)，即 `_User` 表中的 `username` 字段已存在相同的值，此时需要提示用户尝试不同的用户名来注册。同样，邮件 `email` 和手机号码 `mobilePhoneNumber` 字段也要求在各自的列中不能有重复值出现，否则会出现 [203](error_code.html#_203)、[214](error_code.html#_214) 错误。

开发者也可以要求用户使用 Email 做为用户名注册，即在用户提交信息后将 `_User` 表中的 `username` 和 `email` 字段都设为相同的值，这样做的好处是用户在忘记密码的情况下可以直接使用「[邮箱重置密码](#重置密码)」功能，无需再额外绑定电子邮件。

{{link_to_blog_password_reset}}

{% block sns_authdata %}{% endblock %}

{% if node != 'qcloud' and node != 'us' %}
#### 设置手机号码

微信、陌陌等流行应用都会建议用户将账号和一个手机号绑定，这样方便进行身份认证以及日后的密码找回等安全模块的使用。我们也提供了一整套发送短信验证码以及验证手机号的流程，这部分流程以及代码演示请参考 {{ sms_guide_url }}。
{% endif %}

#### Verifying Emails

Enabling email verification in an application's settings allows the application to reserve part of its experience for users with confirmed email addresses. Email verification adds the emailVerified key to the AVUser object. When an AVUser's email is set or modified, emailVerified is set to false. LeanCloud then emails the user a link which will set emailVerified to true.

There are three emailVerified states to consider:

true - the user confirmed his or her email address by clicking on the link LeanCloud emailed them. AVUsers can never have a true value when the user account is first created.
false - at the time the AVUser object was last refreshed, the user had not confirmed his or her email address. If emailVerified is false, consider calling fetch on the AVUser.
missing - the AVUser was created when email verification was off or the AVUser does not have an email.

许多应用会通过验证邮箱来确认用户注册的真实性。如果在 {{app_permission_link}} 中勾选了 **用户注册时，发送验证邮件**，那么当一个 `AVUser` 在注册时设置了邮箱，云端就会向该邮箱自动发送一封包含了激活链接的验证邮件，用户打开该邮件并点击激活链接后便视为通过了验证。

有些用户可能在注册之后并没有点击激活链接，而在未来某一个时间又有验证邮箱的需求，这时需要调用如下接口让云端重新发送验证邮件：

{% block code_send_verify_email %}{% endblock %}

当用户 `AVUser` 通过 `setEmail()` 更新成一个新邮箱并成功 save 后，云端会自动向新邮箱发一封验证邮件，因此开发者**不需要**再单独调用 `requestEmailVerify` 接口来发送验证邮件。

### Logging In

Of course, after you allow users to sign up, you need to let them log in to their account in the future. To do this, you can use the class method logIn.

我们提供了多种登录方式，以满足不同场景的应用。

{% if node=='qcloud' %}
<div class="callout callout-danger">注意：TAB 暂时未开放短信功能，所以所有与短信相关的 API 操作（如使用手机号和验证码进行登录）暂时不能调用。</div>
{% endif %}

#### 用户名和密码登录

{% block code_user_logIn_with_username_and_password %}{% endblock %}

{% if node != 'qcloud' and node != 'us' %}
#### 手机号和密码登录

{{ sms_guide_url }} 可以帮助你更好地理解手机号匹配密码登录的流程以及适用范围，所以推荐详细阅读。

{% block code_user_logIn_with_mobilephonenumber_and_password %}{% endblock %}

以上的手机号码即使没有经过验证，只要密码正确也可以成功登录。如果希望阻止未验证的手机号码用于登录，则需要在 {{app_permission_link}} 中勾选 **未验证手机号码的用户，禁止登录**。这种方式也提高了User Account的合法性与安全性。

#### 手机号和验证码登录

首先，调用发送登录验证码的接口：

{% block code_user_logIn_requestLoginSmsCode %}{% endblock %}

然后在界面上引导用户输入收到的 6 位短信验证码：

{% block code_user_logIn_with_smsCode %}{% endblock %}

{% endif %}

{% block text_current_user %}

{{ sms.fixedVerificationCode("####") }}

#### 单点登录 

如果想实现在当前设备 A 上登录后，强制令之前在其他设备上的登录失效，可以按照以下方案来实现：
{# 2017-09-20 hide method 1
**方案一**：

1. 设备 A 登录成功后，调用 AVUser 的 `refreshSessionToken` 方法，更新服务端的 sessionToken。
2. 设备 B 中的应用启动时，调用 AVUser 的 `isAuthenticated` 方法。由于上一步的操作，此时设备 B 中的 sessionToken 是过期的，因此该方法会返回 false，然后据此来调用 `logout` 方法退出登录。
3. 设备 B 中的应用假设正在使用的过程中，A 设备登录了，B 可能会因为发送请求而接收到错误码为 `403(Forbidden to read/write by class permissions)` 的响应，那么基本可以判断出当前用户的 sessionToken 过期了，此时也应将用户导航到登录页面重新登录。


**方案二**：
#}
1. 建立一个设备表，记录用户登录信息和当前设备的信息。
2. 设备 A 登录成功后，更新设备表，将当前设备标记为当前用户登录的最新设备。
3. 设备 B 中的应用启动时，检查设备表，发现最新设备不是当前设备，调用 AVUser 的 `logout` 方法退出登录。

{# 2017-09-21 hide step 4
1. 集成 [LiveQuery 用户登录事件][livequery-event-login]，当设备 B 收到当前用户的登录事件时，检查最新设备不是当前设备，调用 AVUser 的 logout 方法退出当前登录。
#}

{#
{{ docs.note("较之方案一，方案二要多维护一张设备表，步骤稍繁琐，适用于不具备 `refreshSessionToken` 方法的 SDK。") }}
#}
#### Current User 

It would be bothersome if the user had to log in every time they open your app. You can avoid this by using the cached current AVUser object.

Please note that this functionality is disabled by default on Node.js environments (such as React Native) to discourage stateful usages on server-side configurations. To bypass this behavior on this particular use case, call once AVUser.enableUnsafeCurrentUser() right before using any cached-user related functionalities.

Whenever you use any signup or login methods, the user is cached in localStorage, or in any storage you configured via the AVsetAsyncStorage method. You can treat this cache as a session, and automatically assume the user is logged in:

打开微博或者微信，它不会每次都要求用户都登录，这是因为它将用户数据缓存在了客户端。
同样，只要是调用了登录相关的接口，LeanCloud SDK 都会自动缓存登录用户的数据。
例如，判断当前用户是否为空，为空就跳转到登录页面让用户登录，如果不为空就跳转到首页：

{% block code_current_user %}{% endblock %}
When using a platform with an async storage system you should call currentAsync() instead.
{% block text_current_user_remains_if_not_being_logged_out %}
如果不调用 [登出](#登出) 方法，当前用户的缓存将永久保存在客户端。
{% endblock %}

You can clear the current user by logging them out:


#### SessionToken

If you've created your own authentication routines, or otherwise logged in a user on the server side, you can now pass the session token to the client and use the become method. This method will ensure the session token is valid before setting the current user.

所有登录接口调用成功之后，云端会返回一个 SessionToken 给客户端，客户端在发送 HTTP 请求的时候，{{sdk_name}} 会在 HTTP 请求的 Header 里面自动添加上当前用户的 SessionToken 作为这次请求发起者 `{{userObjectName}}` 的身份认证信息。

如果在 {{app_permission_link}} 中勾选了 **密码修改后，强制客户端重新登录**，那么当用户密码再次被修改后，已登录的用户对象就会失效，开发者需要使用更改后的密码重新调用登录接口，使 SessionToken 得到更新，否则后续操作会遇到 [403 (Forbidden)](error_code.html#_403) 的错误。

{% block text_user_isAuthenticated %}
##### 验证 SessionToken 是否在有效期内

{% block code_user_isAuthenticated %}{% endblock %}

{% endblock %}

{% block text_authenticate_via_sessiontoken %}
##### 使用 SessionToken 登录

Handling Invalid Session Token Error
With revocable sessions, your current session token could become invalid if its corresponding Session object is deleted from the LeanCloud Cloud. This could happen if you implement a Session Manager UI that lets users log out of other devices, or if you manually delete the session via Cloud Code, REST API, or Data Browser. Sessions could also be deleted due to automatic expiration (if configured in app settings). When a device's session token no longer corresponds to a Session object on the LeanCloud Cloud, all API requests from that device will fail with “Error 209: invalid session token”.

To handle this error, we recommend writing a global utility function that is called by all of your LeanCloud request error callbacks. You can then handle the “invalid session token” error in this global function. You should prompt the user to login again so that they can obtain a new session token. This code could look like this:
在没有用户名密码的情况下，客户端可以使用 SessionToken 来登录。常见的使用场景有：

- 应用内根据以前缓存的 SessionToken 登录
- 应用内的某个页面使用 WebView 方式来登录 LeanCloud 
- 在服务端登录后，返回 SessionToken 给客户端，客户端根据返回的 SessionToken 登录。

{% block code_authenticate_via_sessiontoken %}
```javascript
// 1. getSessionToken()
// 2. become(sessionToken)
// 3. 在成功的回调中更新 currentUser 的信息 become(sessionToken)
```
{% endblock %}

{{ docs.alert("请避免在外部浏览器使用 URL 来传递 SessionToken，以防范信息泄露风险。") }}
{# 参见 [云引擎 · SDK 调用云函数](leanengine_cloudfunction_guide-node.html#) #}
{% endblock %}
Sessions represent an instance of a user logged into a device. Sessions are automatically created when users log in or sign up. They are automatically deleted when users log out. There is one distinct Session object for each user-installation pair; if a user issues a login request from a device they're already logged into, that user's previous Session object for that Installation is automatically deleted. Session objects are stored on LeanCloud in the Session class, and you can view them on the AVcom Data Browser. We provide a set of APIs to manage Session objects in your app.

Session is a subclass of a LeanCloud Object, so you can query, update, and delete sessions in the same way that you manipulate normal objects on AV Because the LeanCloud Cloud automatically creates sessions when you log in or sign up users, you should not manually create Session objects unless you are building a “LeanCloud for IoT” app (e.g. Arduino or Embedded C). Deleting a Session will log the user out of the device that is currently using this session's token.

Unlike other LeanCloud objects, the Session class does not have Cloud Code triggers. So you cannot register a beforeSave or afterSave handler for the Session class.

#### 账户锁定

输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 `{"code":1,"error":"登录失败次数超过限制，请稍候再试，或者通过忘记密码重设密码。"}`，开发者可在客户端进行必要提示。

锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。



### Resetting Passwords

It's a fact that as soon as you introduce passwords into a system, users will forget them. In such cases, our library provides a way to let them securely reset their password.

To kick off the password reset flow, ask the user for their email address, and call:
#### 邮箱重置密码

我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了一种安全重置密码的方法。

重置密码的过程很简单，用户只需要输入注册的电子邮件地址即可：

{% block code_reset_password_by_email %}{% endblock %}

This will attempt to match the given email with the user's email or username field, and will send them a password reset email. By doing this, you can opt to have users use their email as their username, or you can collect it separately and store it in the email field.

The flow for password reset is as follows:

User requests that their password be reset by typing in their email.
LeanCloud sends an email to their address, with a special password reset link.
User clicks on the reset link, and is directed to a special LeanCloud page that will allow them type in a new password.
User types in a new password. Their password has now been reset to a value they specify.
Note that the messaging in this flow will reference your app by the name that you specified when you created this app on AV

密码重置流程如下：

1. 用户输入注册的电子邮件，请求重置密码；
2. Cloud storage 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；
3. 用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；
4. 用户的密码已被重置为新输入的密码。

{{link_to_blog_password_reset}}

{% if node != 'qcloud' and node != 'us' %}
#### 手机号码重置密码

{% if node=='qcloud' %}
<div class="callout callout-danger">注意：TAB 暂时未开放短信功能，所以所有与短信相关的 API 操作暂时不能调用。</div>
{% endif %}

与使用 [邮箱重置密码](#邮箱重置密码) 类似，「手机号码重置密码」使用下面的方法来获取短信验证码：

{% block code_reset_password_by_mobilephoneNumber %}{% endblock %}

注意！用户需要先绑定手机号码，然后使用短信验证码来重置密码：

{% block code_reset_password_by_mobilephoneNumber_verify %}{% endblock %}
{% endif %}
#### 登出

用户登出系统时，SDK 会自动清理缓存信息。

{% block code_current_user_logout %}{% endblock %}

{% endblock %}
### Quering Users

The AVUser class is secured by default. Data stored in an AVUser can only be modified by that user. By default, the data can still be read by any client. Thus, some AVUser objects are authenticated and can be modified, whereas others are read-only.

Specifically, you are not able to invoke any of the save or delete methods unless the AVUser was obtained using an authenticated method, like logIn or signUp. This ensures that only the user can alter their own data.

The following illustrates this security policy:
为了安全起见，**新创建的应用的 `_User` 表默认关闭了 find 权限**，这样每位用户登录后只能查询到自己在 `_User` 表中的数据，无法查询其他用户的数据。如果需要让其查询其他用户的数据，建议单独创建一张表来保存这类数据，并开放这张表的 find 查询权限。


The AVUser obtained from AVUser.current() will always be authenticated.

If you need to check if an AVUser is authenticated, you can invoke the authenticated method. You do not need to check authenticated with AVUser objects that are obtained via an authenticated method.

设置数据表权限的方法，请参考 [数据与安全 {{middot}} Class 级别的权限](data_security.html#Class_级别的_ACL)。我们推荐开发者在 [云引擎](leanengine_overview.html) 中封装用户查询，只查询特定条件的用户，避免开放 `_User` 表的全部查询权限。

To query for users, you can simple create a new AVQuery for AVUsers:

查询用户代码如下：
{% block code_query_user %}{% endblock %}

### 浏览器中查看用户表

用户表是一个特殊的表，专门storage用户对象。在浏览器端，你会看到一个 `_User` 表。

### 匿名用户

使用匿名用户，可以让应用不提供注册步骤也能创建用户：

{% block anonymous_user_login %}{% endblock %}

{% block anonymous_user_save %}
如果有需要，应用还可以让匿名用户完善信息，例如设置用户名、密码和邮箱等：

{% block setup_username_and_password_for_anonymous_user %}{% endblock %}

如果没有完善信息，匿名用户一旦登出，其身份就会永久消失。
{% endblock %}

## Roles

关于用户与角色的关系，我们有一个更为详尽的文档介绍这部分的内容，并且针对权限管理有深入的讲解，详情请阅读《[ACL 权限管理指南](acl-guide.html)》。

{% block module_in_app_search %}
## In-App Search

应用内搜索是一个针对应用数据进行全局搜索的接口，它基于搜索引擎构建，提供更强大的搜索功能。要深入了解其用法和阅读示例代码，请阅读 {{inapp_search_guide_url}}。
{% endblock %}



{% if node != 'qcloud' %}
{% block module_in_app_social %}
## In-App Socialing
应用内社交，又称「事件流」，在应用开发中出现的场景非常多，包括用户间关注（好友）、朋友圈（时间线）、状态、互动（点赞）、私信等常用功能，请参考 {{status_system_guide_url}}。
{% endblock %}
{% endif %}

{% if node != 'qcloud' %}
{% block text_sns %}
## SNS
社交账号的登录方便了应用开发者在提升用户体验，我们特地开发了一套支持第三方账号登录的组件，请参考 {{sns_guide_url}}。
{% endblock %}
{% endif %}

{% if node != 'qcloud' %}
{% block text_feedback %}
## User Feedback
用户反馈是一个非常轻量的模块，可以用最少两行的代码来实现一个支持文字和图片的用户反馈系统，并且能够方便的在我们的移动 App 中查看用户的反馈，请参考  {{feedback_guide_url}}。
{% endblock %}
{% endif %}

{% block js_push_guide %}{% endblock %}

{% block use_js_in_webview %}{% endblock %}

{% block faq %}{% endblock %}